import re

import matplotlib.pyplot as plt
import numpy as np


class ResultParser:
    """
    Class for loading, displaying and plotting training progress generated by run_DGCNN.sh script.
    """

    def __init__(self, training_results: str):
        self.dataset, self.batch_size, self.results = self._load_from_txt(
            training_results
        )

    def _load_from_txt(self, training_results: str):
        """
        Parses txt output of run_DGCNN.sh cript to extract training informations.
        Returns dataset name and list of train and test accuracies for every fold and epoch.
        """
        dataset = None
        bsz = None
        data = {}

        # Initialize variables to store the current fold and accuracy lists
        current_fold = None
        train_accuracies = []
        test_accuracies = []
        train_losses = []
        test_losses = []

        # Read the file and process it line by line
        with open(training_results, "r") as file:
            for line in file:
                # Get dataset name
                if dataset is None:
                    dataset_match = re.search(r"data='([^']*)'", line)
                    if dataset_match:
                        dataset = dataset_match.group(1)

                # Get batch size
                if bsz is None:
                    bsz_match = re.search(r"batch_size=(\d+)", line)
                    if bsz_match:
                        bsz = bsz_match.group(1)

                # Check for the Namespace line to get the fold number
                fold_match = re.search(r"Namespace\(.*fold=(\d+),.*\)", line)
                if fold_match:
                    # If we have already collected accuracies for a previous fold, save them
                    if current_fold is not None:
                        data[current_fold] = {
                            "train_accuracy": train_accuracies,
                            "test_accuracy": test_accuracies,
                            "train_loss": train_losses,
                            "test_loss": test_losses,
                        }
                    # Reset for the new fold
                    current_fold = int(fold_match.group(1))
                    train_accuracies = []
                    test_accuracies = []
                    train_losses = []
                    test_losses = []

                # Use regex to find the train accuracy in lines starting with 'average training of epoch'
                train_match_acc = re.search(
                    r"average training of epoch \d+:.*acc ([\d\.]+)", line
                )
                if train_match_acc:
                    train_accuracies.append(float(train_match_acc.group(1)))

                # train loss
                train_match_loss = re.search(
                    r"average training of epoch \d+:.*loss ([\d\.]+)", line
                )
                if train_match_loss:
                    train_losses.append(float(train_match_loss.group(1)))

                # Use regex to find the test accuracy in lines starting with 'average test of epoch'
                test_match_acc = re.search(
                    r"average test of epoch \d+:.*acc ([\d\.]+)", line
                )
                if test_match_acc:
                    test_accuracies.append(float(test_match_acc.group(1)))

                # test loss
                test_match_loss = re.search(
                    r"average test of epoch \d+:.*loss ([\d\.]+)", line
                )
                if test_match_loss:
                    test_losses.append(float(test_match_loss.group(1)))

                # Save the last fold data
                if current_fold is not None:
                    data[current_fold] = {
                        "train_accuracy": train_accuracies,
                        "test_accuracy": test_accuracies,
                        "train_loss": train_losses,
                        "test_loss": test_losses,
                    }

        return dataset, bsz, data

    def fold_acc(self, split: str):
        """
        split can be 'train' or 'test'
        Returns a list of last epoch accuracy for every fold
        """
        result = []
        for _, results in self.results.items():
            result.append(results[f"{split}_accuracy"][-1])

        return result

    def avg_acc(self, split: str):
        """
        Avg accuracy from last epoch of every fold
        """
        last_epoch_acc = self.fold_acc(split)
        return np.mean(last_epoch_acc)
    
    def std_acc(self, split: str):
        """
        Avg accuracy from last epoch of every fold
        """
        last_epoch_acc = self.fold_acc(split)
        return np.std(last_epoch_acc)

    def get_metric_arrays(self, split: str, metric: str):
        """
        metric can be 'accuracy' or 'loss'
        Returns {number of folds} pairs of arrays x and y for plotting, containing accuracy or loss.
        """
        x = []
        y = []

        # Extracting x and y values
        for _, results in self.results.items():
            x.append(range(len(results[f"{split}_{metric}"])))
            y.append(results[f"{split}_{metric}"])

        return x, y

    def mean_for_epoch(self, folds: list):
        """Calculates folds average of metric for every epoch
        epoch        0, 1, 2
        fold1_acc = [1, 2, 3, ...]
        fold2_acc = [1, 0, 4, ...]
        fold3_acc = [1, 4, 5, ...]

        avg       = [1, 3, 4, ...]
        """
        result = [np.mean([fold[i] for fold in folds]) for i in range(len(folds[0]))]
        return result

    def plot_metric(self, split: str, metric: str):
        """
        split: can be 'train' or 'test'
        metric: can be 'accuracy' or 'loss'

        Plots folds training accuracies for every epoch
        """

        x, y = self.get_metric_arrays(split, metric)

        # Plotting all folds on the same plot with different colors and legend
        plt.figure(figsize=(10, 6))
        for i in range(len(x)):
            plt.plot(x[i], y[i], label=f"Fold {i+1}")

        # Calculating and plotting average accuracy
        avg_accuracy = self.mean_for_epoch(y)

        plt.plot(
            range(len(avg_accuracy)),
            avg_accuracy,
            label="Average",
            linestyle="--",
            color="black",
        )

        # Adding titles, labels, and legend
        plt.title(f"{metric} per fold and average {metric} for {split} set of {self.dataset}")
        plt.xlabel("Epoch")
        plt.ylabel(metric)
        plt.legend(bbox_to_anchor=(1.05, 1), loc="upper left")

        # Adjust layout to make room for the legend
        plt.tight_layout(rect=[0, 0, 0.85, 1])

        plt.show()

    def plot_averaged_metric(self, metric: str):
        """
        Plots averaged accuracies for every epoch
        """

        _, y = self.get_metric_arrays("train", metric)
        avg_accuracy_train = self.mean_for_epoch(y)
        _, y = self.get_metric_arrays("test", metric)
        avg_accuracy_test = self.mean_for_epoch(y)

        plt.plot(
            range(len(avg_accuracy_train)),
            avg_accuracy_train,
            label="train",
            linestyle="--",
            color="blue",
        )
        plt.plot(
            range(len(avg_accuracy_test)),
            avg_accuracy_test,
            label="test",
            linestyle="--",
            color="green",
        )

        plt.title(f"Comparison of average {metric} for train and test set of {self.dataset}")
        plt.xlabel("Epoch")
        plt.ylabel(metric)
        plt.legend()
        plt.show()

    def display_basic_metrics(self):
        print(f"Result for dataset {self.dataset} calculated with batch size {self.batch_size}")
        print()
        print(f"Last epoch accuracy for every fold on train set: {self.fold_acc(split='train')}")
        print(f"Last epoch accuracy for every fold on test set: {self.fold_acc(split='test')}")
        print()
        print(f"Average last epoch accuracy on train set: {self.avg_acc(split='train')}")
        print(f"Last epoch accuracy std on train set: {self.std_acc(split='train')}")
        print(f"Average last epoch accuracy on test set: {self.avg_acc(split='test')}")
        print(f"Last epoch accuracy std on test set: {self.std_acc(split='test')}")